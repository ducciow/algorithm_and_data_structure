package systematic.section30_Hash;

/**
 * @Author: duccio
 * @Date: 16, 05, 2022
 * @Description: A structure for storing old values, and search exist when new values come.
 * @Note:   1. Prepare an array of size m for bits.
 *          2. To store values, use k hash functions to get k hashcode, modulo them by m, and mark k positions in
 *             the array.
 *          3. When a new value comes, use k hash functions to get k hashcode, modulo them by m, and get k positions
 *             from the array. If all positions are marked, then this value is old.
 *          ======
 *          1. Might have false positives.
 *          2. Two hyper-parameters: size and number of hash functions.
 *          3. Trade-off between space and false positive.
 *          4. Has three equations, with sample size and false positive rate as the factors.
 *          ======
 *          New hash functions can be generated by linearly combination of two existing hash functions: f = a*f1 + f2.
 */
public class Code02_BloomFilter {

    /*

    N: sample size
    P: expected false positive rate
    M: bloom filter size
    K: number of hash functions

    M = ceil(- (N * lnP) / (ln2)**2)
    K = ceil(ln2 * M / N)
      = ceil(0.7 * M / N)
    P_real = (1 - e**-(NK/M))**K

     */

}
